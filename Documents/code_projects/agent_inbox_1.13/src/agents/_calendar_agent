"""
Calendar Agent - Recherche R√âELLE dans Google Calendar
"""

import json
import os
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo

from googleapiclient.errors import HttpError
from googleapiclient.discovery import build
from langsmith import traceable
from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request

from src.agents.base_agent import BaseAgent
from src.models.state import AgentState, CalendarData


class CalendarAgent(BaseAgent):
    """Agent qui interroge VRAIMENT Google Calendar pour trouver des disponibilit√©s"""

    SCOPES = ['https://www.googleapis.com/auth/calendar.readonly',
              'https://www.googleapis.com/auth/calendar.events']
    TIMEZONE = 'America/Montreal'

    def __init__(self):
        super().__init__(
            name="calendar_agent",
            model="gpt-4o",
            temperature=0.1
        )
        self.service = self._init_calendar_service()
        self.tz = ZoneInfo(self.TIMEZONE)

    def _init_calendar_service(self):
        """Initialise le service Google Calendar avec les bonnes credentials"""
        try:
            from dotenv import load_dotenv
            load_dotenv()

            client_id = os.getenv('GOOGLE_CLIENT_ID')
            client_secret = os.getenv('GOOGLE_CLIENT_SECRET')
            refresh_token = os.getenv('GMAIL_REFRESH_TOKEN')

            if all([client_id, client_secret, refresh_token]):
                creds = Credentials(
                    token=None,
                    refresh_token=refresh_token,
                    client_id=client_id,
                    client_secret=client_secret,
                    token_uri='https://oauth2.googleapis.com/token',
                    scopes=self.SCOPES
                )

                creds.refresh(Request())
                service = build('calendar', 'v3', credentials=creds)

                # Tester la connexion
                calendar_list = service.calendarList().list(maxResults=1).execute()
                self.logger.info(f"‚úÖ Calendar connect√©")
                return service

        except Exception as e:
            self.logger.error(f"‚ùå Erreur connexion Calendar: {e}")

        return None

    @traceable(name="calendar_process", tags=["agent", "calendar"])
    async def process(self, state: AgentState) -> AgentState:
        """Trouve 2 cr√©neaux disponibles dans le vrai calendrier Google"""
        try:
            self.logger.info("üîç Recherche de disponibilit√©s calendrier")

            # Parser la requ√™te
            request = await self._extract_meeting_info(state)

            # Chercher 2 cr√©neaux libres
            slots = await self._search_real_availability(request)

            # Stocker les r√©sultats
            if not state.calendar_data:
                state.calendar_data = CalendarData()

            state.calendar_data.suggested_times = slots
            state.calendar_data.meeting_request = request
            state.response_metadata["calendar_suggestions"] = slots

            # Formater la r√©ponse
            message = self._format_response(slots, request)
            self._add_message(state, message)

            return state

        except Exception as e:
            self.logger.error(f"Erreur Calendar: {e}", exc_info=True)
            # Fallback avec slots par d√©faut
            slots = self._mock_slots()
            message = self._format_response(slots, {'title': 'votre rendez-vous'})
            self._add_message(state, message)
            return state

    async def _extract_meeting_info(self, state: AgentState) -> Dict:
        """Extrait les infos du meeting demand√© de mani√®re s√ªre"""
        email_text = ""
        if state.email:
            email_text = f"{state.email.subject or ''} {state.email.body or ''}"

        # R√©cup√©rer les dates de mani√®re s√ªre
        dates_list = []

        # V√©rifier quels attributs ExtractedContext poss√®de vraiment
        if state.extracted_context:
            # Utiliser getattr pour √©viter les erreurs
            dates_mentioned = getattr(state.extracted_context, 'dates_mentioned', None)
            if dates_mentioned:
                dates_list.extend(dates_mentioned if isinstance(dates_mentioned, list) else [dates_mentioned])

            # Essayer d'autres attributs possibles
            for attr in ['requested_dates', 'dates', 'meeting_dates']:
                value = getattr(state.extracted_context, attr, None)
                if value:
                    dates_list.extend(value if isinstance(value, list) else [value])
                    break

        # Aussi v√©rifier dans response_metadata
        if state.response_metadata:
            context = state.response_metadata.get('context_extraction', {})
            if isinstance(context, dict):
                dates_from_meta = context.get('dates_mentioned', [])
                if dates_from_meta:
                    dates_list.extend(dates_from_meta)

        prompt = f"""Analyse cette demande de rendez-vous et extrait les informations:

Email: {email_text[:500]}
Dates trouv√©es: {dates_list}

Retourne UNIQUEMENT ce JSON (rien d'autre):
{{
  "title": "Rendez-vous avec [nom] ou Meeting",
  "duration": 30,
  "dates_preferred": [],
  "time_preference": "any"
}}

Si des dates sont mentionn√©es, mets-les dans dates_preferred au format YYYY-MM-DD.
time_preference peut √™tre: morning, afternoon, ou any"""

        try:
            response = await self._call_llm(prompt)
            # Nettoyer la r√©ponse pour n'avoir que le JSON
            response = response.strip()
            if response.startswith('```json'):
                response = response[7:]
            if response.startswith('```'):
                response = response[3:]
            if response.endswith('```'):
                response = response[:-3]

            info = json.loads(response.strip())

            # Valeurs par d√©faut
            info.setdefault('duration', 30)
            info.setdefault('time_preference', 'any')
            info.setdefault('dates_preferred', [])

            self.logger.info(f"Meeting extrait: {info['title']}, dur√©e: {info['duration']}min")

            return info

        except Exception as e:
            self.logger.error(f"Erreur parsing meeting: {e}")
            return {
                'title': 'Rendez-vous',
                'duration': 30,
                'time_preference': 'any',
                'dates_preferred': []
            }

    async def _search_real_availability(self, request: Dict) -> List[Dict]:
        """Recherche dans Google Calendar ou retourne des slots par d√©faut"""
        if not self.service:
            self.logger.warning("Pas de service Calendar - utilisation des slots par d√©faut")
            return self._mock_slots()

        duration = request.get('duration', 30)
        preference = request.get('time_preference', 'any')
        preferred_dates = request.get('dates_preferred', [])

        found_slots = []

        # Commencer demain
        now = datetime.now(self.tz)
        search_start = (now + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)

        # Skip weekend pour le d√©but
        while search_start.weekday() >= 5:
            search_start += timedelta(days=1)

        # Chercher dans les prochains jours ouvrables
        current = search_start
        days_checked = 0
        max_days = 10  # R√©duit pour performance

        while len(found_slots) < 2 and days_checked < max_days:
            if current.weekday() < 5:  # Jours ouvrables
                slots = await self._check_date_availability(current, duration, preference)
                found_slots.extend(slots[:2-len(found_slots)])
                days_checked += 1

            current += timedelta(days=1)

        self.logger.info(f"‚úÖ {len(found_slots)} cr√©neaux trouv√©s")

        # Si pas assez de slots, ajouter des slots par d√©faut
        if len(found_slots) < 2:
            mock = self._mock_slots()
            found_slots.extend(mock[:2-len(found_slots)])

        return found_slots[:2]

    async def _check_date_availability(self, date: datetime, duration: int, preference: str) -> List[Dict]:
        """V√©rifie les disponibilit√©s pour une date"""
        slots = []

        # Heures selon pr√©f√©rence
        if preference == 'morning':
            hours = [(9, 0), (10, 0), (11, 0)]
        elif preference == 'afternoon':
            hours = [(14, 0), (15, 0), (16, 0)]
        else:
            hours = [(9, 0), (10, 30), (14, 0), (15, 30)]

        for hour, minute in hours:
            if len(slots) >= 1:  # Max 1 slot par jour
                break

            start = date.replace(hour=hour, minute=minute, second=0, microsecond=0)
            end = start + timedelta(minutes=duration)

            # V√©rifier limites
            if end.hour > 17 or (end.hour == 17 and end.minute > 30):
                continue

            # V√©rifier disponibilit√©
            if await self._is_time_free(start, end):
                slots.append({
                    'date': start.strftime('%Y-%m-%d'),
                    'time': start.strftime('%H:%M'),
                    'start': start.isoformat(),
                    'end': end.isoformat(),
                    'duration': duration
                })

        return slots

    async def _is_time_free(self, start: datetime, end: datetime) -> bool:
        """V√©rifie si le cr√©neau est libre"""
        if not self.service:
            return True

        try:
            events_result = self.service.events().list(
                calendarId='primary',
                timeMin=start.isoformat(),
                timeMax=end.isoformat(),
                singleEvents=True,
                maxResults=1
            ).execute()

            return len(events_result.get('items', [])) == 0

        except Exception as e:
            self.logger.error(f"Erreur API Calendar: {e}")
            return True  # En cas d'erreur, consid√©rer comme libre

    def _format_response(self, slots: List[Dict], request: Dict) -> str:
        """Formate les 2 suggestions"""
        if not slots:
            return "‚ùå Aucune disponibilit√© trouv√©e."

        title = request.get('title', 'votre rendez-vous')
        lines = [f"üìÖ Voici 2 disponibilit√©s pour {title}:\n"]

        days_fr = ['lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi', 'dimanche']
        months_fr = ['', 'janvier', 'f√©vrier', 'mars', 'avril', 'mai', 'juin',
                     'juillet', 'ao√ªt', 'septembre', 'octobre', 'novembre', 'd√©cembre']

        for i, slot in enumerate(slots[:2], 1):
            dt = datetime.fromisoformat(slot['start'])
            day = days_fr[dt.weekday()]
            month = months_fr[dt.month]

            lines.append(f"**Option {i}**: {day} {dt.day} {month} √† {slot['time']} ({slot['duration']}min)")

        lines.append("\n‚úÖ Ces cr√©neaux sont disponibles dans votre agenda.")
        return "\n".join(lines)

    def _mock_slots(self) -> List[Dict]:
        """Slots par d√©faut si pas de connexion"""
        tomorrow = datetime.now(self.tz) + timedelta(days=1)
        while tomorrow.weekday() >= 5:
            tomorrow += timedelta(days=1)

        day_after = tomorrow + timedelta(days=1)
        while day_after.weekday() >= 5:
            day_after += timedelta(days=1)

        return [
            {
                'date': tomorrow.strftime('%Y-%m-%d'),
                'time': '10:00',
                'start': tomorrow.replace(hour=10, minute=0).isoformat(),
                'end': tomorrow.replace(hour=10, minute=30).isoformat(),
                'duration': 30
            },
            {
                'date': day_after.strftime('%Y-%m-%d'),
                'time': '14:00',
                'start': day_after.replace(hour=14, minute=0).isoformat(),
                'end': day_after.replace(hour=14, minute=30).isoformat(),
                'duration': 30
            }
        ]
