"""
Calendar Agent - Recherche RÃ‰ELLE dans Google Calendar
"""

import json
import os
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo

from googleapiclient.errors import HttpError
from googleapiclient.discovery import build
from langsmith import traceable
from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request

from src.agents.base_agent import BaseAgent
from src.models.state import AgentState, CalendarData


class CalendarAgent(BaseAgent):
    """Agent qui interroge VRAIMENT Google Calendar pour trouver des disponibilitÃ©s"""

    SCOPES = ['https://www.googleapis.com/auth/calendar.readonly',
              'https://www.googleapis.com/auth/calendar.events']
    TIMEZONE = 'America/Montreal'

    def __init__(self):
        super().__init__(
            name="calendar_agent",
            model="gpt-4o",
            temperature=0.1
        )
        self.service = self._init_calendar_service()
        self.tz = ZoneInfo(self.TIMEZONE)

    def _init_calendar_service(self):
        """Initialise le service Google Calendar avec les bonnes credentials"""
        try:
            from dotenv import load_dotenv
            load_dotenv()

            client_id = os.getenv('GOOGLE_CLIENT_ID')
            client_secret = os.getenv('GOOGLE_CLIENT_SECRET')
            refresh_token = os.getenv('GMAIL_REFRESH_TOKEN')

            if all([client_id, client_secret, refresh_token]):
                creds = Credentials(
                    token=None,
                    refresh_token=refresh_token,
                    client_id=client_id,
                    client_secret=client_secret,
                    token_uri='https://oauth2.googleapis.com/token',
                    scopes=self.SCOPES
                )

                creds.refresh(Request())
                service = build('calendar', 'v3', credentials=creds)

                # Tester la connexion
                calendar_list = service.calendarList().list(maxResults=1).execute()
                self.logger.info(f"âœ… Calendar connectÃ©")
                return service

        except Exception as e:
            self.logger.error(f"âŒ Erreur connexion Calendar: {e}")

        return None

    @traceable(name="calendar_process", tags=["agent", "calendar"])
    async def process(self, state: AgentState) -> AgentState:
        """Trouve 2 crÃ©neaux disponibles dans le vrai calendrier Google"""
        try:
            self.logger.info("ðŸ” Recherche de disponibilitÃ©s calendrier")

            # Parser la requÃªte
            request = await self._extract_meeting_info(state)

            # Chercher 2 crÃ©neaux libres
            slots = await self._search_real_availability(request)

            # Stocker les rÃ©sultats
            if not state.calendar_data:
                state.calendar_data = CalendarData()

            state.calendar_data.suggested_times = slots
            state.calendar_data.meeting_request = request
            state.response_metadata["calendar_suggestions"] = slots

            # Formater la rÃ©ponse
            message = self._format_response(slots, request)
            self._add_message(state, message)

            return state

        except Exception as e:
            self.logger.error(f"Erreur Calendar: {e}", exc_info=True)
            # Fallback avec slots par dÃ©faut
            slots = self._mock_slots()
            message = self._format_response(slots, {'title': 'votre rendez-vous'})
            self._add_message(state, message)
            return state

    async def _extract_meeting_info(self, state: AgentState) -> Dict:
        """Extrait les infos du meeting demandÃ© de maniÃ¨re sÃ»re"""
        email_text = ""
        if state.email:
            email_text = f"{state.email.subject or ''} {state.email.body or ''}"

        # RÃ©cupÃ©rer les dates de maniÃ¨re sÃ»re
        dates_list = []

        # VÃ©rifier quels attributs ExtractedContext possÃ¨de vraiment
        if state.extracted_context:
            # Utiliser getattr pour Ã©viter les erreurs
            dates_mentioned = getattr(state.extracted_context, 'dates_mentioned', None)
            if dates_mentioned:
                dates_list.extend(dates_mentioned if isinstance(dates_mentioned, list) else [dates_mentioned])

            # Essayer d'autres attributs possibles
            for attr in ['requested_dates', 'dates', 'meeting_dates']:
                value = getattr(state.extracted_context, attr, None)
                if value:
                    dates_list.extend(value if isinstance(value, list) else [value])
                    break

        # Aussi vÃ©rifier dans response_metadata
        if state.response_metadata:
            context = state.response_metadata.get('context_extraction', {})
            if isinstance(context, dict):
                dates_from_meta = context.get('dates_mentioned', [])
                if dates_from_meta:
                    dates_list.extend(dates_from_meta)

        prompt = f"""Analyse cette demande de rendez-vous et extrait les informations:

Email: {email_text[:500]}
Dates trouvÃ©es: {dates_list}

Retourne UNIQUEMENT ce JSON (rien d'autre):
{{
  "title": "Rendez-vous avec [nom] ou Meeting",
  "duration": 30,
  "dates_preferred": [],
  "time_preference": "any"
}}

Si des dates sont mentionnÃ©es, mets-les dans dates_preferred au format YYYY-MM-DD.
time_preference peut Ãªtre: morning, afternoon, ou any"""

        try:
            response = await self._call_llm(prompt)
            # Nettoyer la rÃ©ponse pour n'avoir que le JSON
            response = response.strip()
            if response.startswith('```json'):
                response = response[7:]
            if response.startswith('```'):
                response = response[3:]
            if response.endswith('```'):
                response = response[:-3]

            info = json.loads(response.strip())

            # Valeurs par dÃ©faut
            info.setdefault('duration', 30)
            info.setdefault('time_preference', 'any')
            info.setdefault('dates_preferred', [])

            self.logger.info(f"Meeting extrait: {info['title']}, durÃ©e: {info['duration']}min")

            return info

        except Exception as e:
            self.logger.error(f"Erreur parsing meeting: {e}")
            return {
                'title': 'Rendez-vous',
                'duration': 30,
                'time_preference': 'any',
                'dates_preferred': []
            }

    async def _search_real_availability(self, request: Dict) -> List[Dict]:
        """Recherche dans Google Calendar ou retourne des slots par dÃ©faut"""
        if not self.service:
            self.logger.warning("Pas de service Calendar - utilisation des slots par dÃ©faut")
            return self._mock_slots()

        duration = request.get('duration', 30)
        preference = request.get('time_preference', 'any')
        preferred_dates = request.get('dates_preferred', [])

        found_slots = []

        # Commencer demain
        now = datetime.now(self.tz)
        search_start = (now + timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)

        # Skip weekend pour le dÃ©but
        while search_start.weekday() >= 5:
            search_start += timedelta(days=1)

        # Chercher dans les prochains jours ouvrables
        current = search_start
        days_checked = 0
        max_days = 10  # RÃ©duit pour performance

        while len(found_slots) < 2 and days_checked < max_days:
            if current.weekday() < 5:  # Jours ouvrables
                slots = await self._check_date_availability(current, duration, preference)
                found_slots.extend(slots[:2-len(found_slots)])
                days_checked += 1

            current += timedelta(days=1)

        self.logger.info(f"âœ… {len(found_slots)} crÃ©neaux trouvÃ©s")

        # Si pas assez de slots, ajouter des slots par dÃ©faut
        if len(found_slots) < 2:
            mock = self._mock_slots()
            found_slots.extend(mock[:2-len(found_slots)])

        return found_slots[:2]

    async def _check_date_availability(self, date: datetime, duration: int, preference: str) -> List[Dict]:
        """VÃ©rifie les disponibilitÃ©s pour une date"""
        slots = []

        # Heures selon prÃ©fÃ©rence
        if preference == 'morning':
            hours = [(9, 0), (10, 0), (11, 0)]
        elif preference == 'afternoon':
            hours = [(14, 0), (15, 0), (16, 0)]
        else:
            hours = [(9, 0), (10, 30), (14, 0), (15, 30)]

        for hour, minute in hours:
            if len(slots) >= 1:  # Max 1 slot par jour
                break

            start = date.replace(hour=hour, minute=minute, second=0, microsecond=0)
            end = start + timedelta(minutes=duration)

            # VÃ©rifier limites
            if end.hour > 17 or (end.hour == 17 and end.minute > 30):
                continue

            # VÃ©rifier disponibilitÃ©
            if await self._is_time_free(start, end):
                slots.append({
                    'date': start.strftime('%Y-%m-%d'),
                    'time': start.strftime('%H:%M'),
                    'start': start.isoformat(),
                    'end': end.isoformat(),
                    'duration': duration
                })

        return slots

    async def _is_time_free(self, start: datetime, end: datetime) -> bool:
        """VÃ©rifie si le crÃ©neau est libre"""
        if not self.service:
            return True

        try:
            events_result = self.service.events().list(
                calendarId='primary',
                timeMin=start.isoformat(),
                timeMax=end.isoformat(),
                singleEvents=True,
                maxResults=1
            ).execute()

            return len(events_result.get('items', [])) == 0

        except Exception as e:
            self.logger.error(f"Erreur API Calendar: {e}")
            return True  # En cas d'erreur, considÃ©rer comme libre

    def _format_response(self, slots: List[Dict], request: Dict) -> str:
        """Formate les 2 suggestions"""
        if not slots:
            return "âŒ Aucune disponibilitÃ© trouvÃ©e."

        title = request.get('title', 'votre rendez-vous')
        lines = [f"ðŸ“… Voici 2 disponibilitÃ©s pour {title}:\n"]

        days_fr = ['lundi', 'mardi', 'mercredi', 'jeudi', 'vendredi', 'samedi', 'dimanche']
        months_fr = ['', 'janvier', 'fÃ©vrier', 'mars', 'avril', 'mai', 'juin',
                     'juillet', 'aoÃ»t', 'septembre', 'octobre', 'novembre', 'dÃ©cembre']

        for i, slot in enumerate(slots[:2], 1):
            dt = datetime.fromisoformat(slot['start'])
            day = days_fr[dt.weekday()]
            month = months_fr[dt.month]

            lines.append(f"**Option {i}**: {day} {dt.day} {month} Ã  {slot['time']} ({slot['duration']}min)")

        lines.append("\nâœ… Ces crÃ©neaux sont disponibles dans votre agenda.")
        return "\n".join(lines)

    def _mock_slots(self) -> List[Dict]:
        """Slots par dÃ©faut si pas de connexion"""
        tomorrow = datetime.now(self.tz) + timedelta(days=1)
        while tomorrow.weekday() >= 5:
            tomorrow += timedelta(days=1)

        day_after = tomorrow + timedelta(days=1)
        while day_after.weekday() >= 5:
            day_after += timedelta(days=1)

        return [
            {
                'date': tomorrow.strftime('%Y-%m-%d'),
                'time': '10:00',
                'start': tomorrow.replace(hour=10, minute=0).isoformat(),
                'end': tomorrow.replace(hour=10, minute=30).isoformat(),
                'duration': 30
            },
            {
                'date': day_after.strftime('%Y-%m-%d'),
                'time': '14:00',
                'start': day_after.replace(hour=14, minute=0).isoformat(),
                'end': day_after.replace(hour=14, minute=30).isoformat(),
                'duration': 30
            }
        ]
