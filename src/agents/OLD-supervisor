"""
Supervisor Agent - Hybrid LangGraph Supervisor
Makes intelligent routing decisions using LLM, works with existing workflow nodes
"""

from typing import Dict, Any, List
from langsmith import traceable
from langchain.chat_models import init_chat_model
from langchain_core.messages import HumanMessage, AIMessage
import json

from src.models.state import AgentState
from src.agents.base_agent import BaseAgent
import structlog

logger = structlog.get_logger(__name__)


class SupervisorAgent(BaseAgent):
    """
    Hybrid supervisor that makes intelligent routing decisions.
    Uses LLM to analyze context and decide which agent should work next.
    Works with existing workflow nodes instead of recreating agents.
    """

    def __init__(self):
        super().__init__(
            name="supervisor",
            model="gpt-4o",
            temperature=0.1
        )

    async def process(self, state: AgentState, runtime=None) -> Dict[str, Any]:
        """
        Analyze current state and decide which agent should work next.
        Hub-and-spoke supervisor that coordinates all agent work.
        """
        logger.info("🧭 Supervisor analyzing state for routing decision")

        try:
            # Check if this is initial routing or returning from an agent
            is_returning_from_agent = self._is_returning_from_agent(state)

            if is_returning_from_agent:
                logger.info("📥 Agent completed work, supervisor analyzing results")
            else:
                logger.info("🎯 Initial routing decision needed")

            # Build context for routing decision
            context = self._build_context_summary(state)

            # Make routing decision using LLM
            routing_decision = await self._make_routing_decision(context, state, is_returning_from_agent)

            # Create routing metadata
            routing_metadata = {
                "next": routing_decision["next_agent"],
                "reasoning": routing_decision["reasoning"],
                "supervisor_routed": True,
                "is_returning_from_agent": is_returning_from_agent,
                "routed_at": "now"
            }

            # Create supervisor message
            supervisor_msg = self.create_ai_message(
                f"Routing to {routing_decision['next_agent']}: {routing_decision['reasoning']}",
                metadata={"routing_decision": routing_decision}
            )

            logger.info(f"📍 Supervisor routing to: {routing_decision['next_agent']}")

            return {
                "messages": [supervisor_msg],
                "response_metadata": {"routing": routing_metadata},
                "current_agent": routing_decision['next_agent']
            }

        except Exception as e:
            logger.error(f"❌ Supervisor routing failed: {e}", exc_info=True)

            # Fallback to adaptive_writer
            fallback_msg = self.create_ai_message(
                f"Supervisor error, defaulting to adaptive_writer: {str(e)}"
            )

            return {
                "messages": [fallback_msg],
                "response_metadata": {"routing": {"next": "adaptive_writer", "error": str(e)}},
                "current_agent": "adaptive_writer"
            }

    def _is_returning_from_agent(self, state: AgentState) -> bool:
        """Check if supervisor is receiving results from a completed agent"""
        if not state.messages:
            return False

        # Look for recent agent messages indicating completed work
        for msg in state.messages[-3:]:
            if hasattr(msg, 'name'):
                agent_name = getattr(msg, 'name', '')
                if agent_name in ['calendar_agent', 'rag_agent', 'crm_agent', 'adaptive_writer']:
                    logger.info(f"🔍 Detected recent work from: {agent_name}")
                    return True

        # Check if adaptive_writer completed (has draft_response)
        if state.draft_response and state.current_agent == 'adaptive_writer':
            logger.info("🔍 Detected adaptive_writer completion - has draft_response")
            return True

        # Also check if we have new data that suggests agent work was completed
        has_new_data = bool(state.calendar_data or state.document_data or state.contact_data)
        return has_new_data

    def _build_context_summary(self, state: AgentState) -> str:
        """Build context summary for routing decision"""
        context_parts = []

        # Email context
        if state.email:
            context_parts.append(f"EMAIL:")
            context_parts.append(f"- From: {state.email.sender}")
            context_parts.append(f"- Subject: {state.email.subject}")
            context_parts.append(f"- Body preview: {state.email.body[:200]}...")

        # Extracted context from email processor
        if state.extracted_context:
            context_parts.append(f"\nEMAIL REQUIREMENTS:")
            if hasattr(state.extracted_context, 'requested_actions') and state.extracted_context.requested_actions:
                context_parts.append(f"- Actions requested: {state.extracted_context.requested_actions}")
            if hasattr(state.extracted_context, 'dates_mentioned') and state.extracted_context.dates_mentioned:
                context_parts.append(f"- Dates mentioned: {state.extracted_context.dates_mentioned}")

        # Current data status - what agents have provided
        completed_work = []
        calendar_work_complete = False
        if state.calendar_data:
            calendar_info = str(state.calendar_data.action_taken if hasattr(state.calendar_data, 'action_taken') else 'data available')
            completed_work.append(f"✅ Calendar: {calendar_info[:100]}")
            # Check if calendar work is actually complete (found conflicts or available slots)
            if any(keyword in calendar_info.lower() for keyword in ["conflict", "alternative", "available", "suggested", "slots"]):
                calendar_work_complete = True

        if state.document_data:
            completed_work.append(f"✅ Documents: {str(state.document_data)[:100]}...")
        if state.contact_data:
            completed_work.append(f"✅ Contacts: {str(state.contact_data)[:100]}...")

        if completed_work:
            context_parts.append(f"\nCOMPLETED AGENT WORK:")
            for work in completed_work:
                context_parts.append(f"- {work}")

        # Add calendar completion status
        if calendar_work_complete:
            context_parts.append(f"📅 CALENDAR STATUS: Analysis complete - conflicts/alternatives identified")

        # Recent work done - focus on agent outputs
        if state.messages:
            context_parts.append(f"\nRECENT AGENT MESSAGES:")
            agent_messages = [msg for msg in state.messages[-5:]
                            if hasattr(msg, 'name') and getattr(msg, 'name') in ['calendar_agent', 'rag_agent', 'crm_agent', 'adaptive_writer']]
            for msg in agent_messages:
                name = getattr(msg, 'name', 'unknown')
                content = str(getattr(msg, 'content', ''))[:150]
                context_parts.append(f"- {name}: {content}...")

                # Special check for calendar completion
                if name == 'calendar_agent' and any(keyword in content.lower() for keyword in ["conflict", "alternative slots", "available", "suggested", "feel free to choose"]):
                    context_parts.append(f"  ⚠️ CALENDAR ANALYSIS COMPLETE - Ready for response writing")

        # Human feedback - be specific about what type of changes are requested
        if state.human_feedback or state.response_metadata.get("human_feedback_processed"):
            context_parts.append(f"\nHUMAN FEEDBACK: Present - requires agent re-work")

            # Check if feedback is about scheduling/calendar changes
            feedback_text = ""
            if state.human_feedback:
                feedback_text += str(state.human_feedback).lower()
            if state.response_metadata.get("human_feedback_processed"):
                hf_data = state.response_metadata["human_feedback_processed"]
                if isinstance(hf_data, dict):
                    if "decision" in hf_data:
                        context_parts.append(f"- Decision: {hf_data.get('decision', 'unknown')}")
                    # Add any feedback content for analysis
                    for key in ["modifications_requested", "content", "human_readable"]:
                        if key in hf_data and hf_data[key]:
                            feedback_text += str(hf_data[key]).lower()

            # Identify type of feedback for better routing
            if any(word in feedback_text for word in ["time", "schedule", "meeting", "appointment", "calendar", "date", "pm", "am", "hour", "reschedule", "change time"]):
                context_parts.append(f"- TYPE: CALENDAR/SCHEDULING feedback - needs calendar_agent")
            elif any(word in feedback_text for word in ["contact", "person", "people", "invite", "attendee"]):
                context_parts.append(f"- TYPE: CONTACT feedback - needs crm_agent")
            elif any(word in feedback_text for word in ["document", "information", "search", "find", "lookup"]):
                context_parts.append(f"- TYPE: INFORMATION feedback - needs rag_agent")
            else:
                context_parts.append(f"- TYPE: RESPONSE feedback - may need adaptive_writer")

        # Current draft status
        if state.draft_response:
            context_parts.append(f"\nCURRENT DRAFT: {state.draft_response[:150]}...")

        return "\n".join(context_parts)

    async def _make_routing_decision(self, context: str, state: AgentState, is_returning: bool = False) -> Dict[str, Any]:
        """Use LLM to make intelligent routing decision"""

        # Check which agents have already completed their work to prevent loops
        completed_agents = self._get_completed_agents(state)
        logger.info(f"🔍 Already completed agents: {completed_agents}")

        if is_returning:
            system_prompt = """You are a supervisor analyzing results from completed agents:

- calendar_agent: Handles scheduling, meetings, appointments, availability checks, time coordination, BOOKING CHANGES
- rag_agent: Retrieves documents, searches knowledge base, finds information
- crm_agent: Manages contacts, customer data, relationship information
- adaptive_writer: Composes final email responses (only use when all needed data is gathered)

CRITICAL RULES:
1. If calendar_agent has already provided conflict analysis and alternative times → DO NOT route back to calendar_agent
2. If calendar_agent shows "alternatives suggested" or "conflicts identified" → route to adaptive_writer
3. Only route to calendar_agent if NO calendar analysis exists yet
4. If human feedback requests time changes AND calendar_agent hasn't analyzed yet → route to calendar_agent
5. If calendar work is complete → route to adaptive_writer to compose response

An agent just completed work and reported back. Analyze what was accomplished and decide the next step.

Respond in JSON format with your routing decision."""

            user_prompt = f"""An agent just completed work. Analyze the results and decide next steps:

{context}

AGENTS THAT HAVE ALREADY COMPLETED THEIR WORK: {completed_agents}
⚠️ DO NOT route to agents that have already completed their core work!

CRITICAL ANALYSIS:
1. What specific work was just completed by the agent?
2. What NEW information is now available?
3. Has calendar_agent already provided conflict analysis and alternatives?
4. Does HUMAN FEEDBACK request changes that require NEW agent work?
5. Are there any gaps still remaining for the email request?
6. Is all necessary data now gathered to write a complete response?

ROUTING PRIORITY (AVOID INFINITE LOOPS):
- If calendar_agent already provided alternatives/conflicts → route to adaptive_writer (NOT calendar_agent again)
- If calendar_agent hasn't analyzed yet AND scheduling needed → route to calendar_agent
- If human feedback requests contact changes → route to crm_agent
- If human feedback requests information lookup → route to rag_agent
- If all required information is available → route to adaptive_writer
- If task is fully complete → use FINISH

Return JSON:
{{
    "next_agent": "agent_name_or_FINISH",
    "reasoning": "detailed analysis of completed work and why this next step is needed",
    "confidence": 0.0-1.0
}}"""
        else:
            system_prompt = """You are a supervisor routing emails to specialized agents:

- calendar_agent: Handles scheduling, meetings, appointments, availability checks, time coordination
- rag_agent: Retrieves documents, searches knowledge base, finds information
- crm_agent: Manages contacts, customer data, relationship information
- adaptive_writer: Composes final email responses (only use when all needed data is gathered)

Analyze the email context and decide which ONE agent should work first.

Respond in JSON format with your routing decision."""

            user_prompt = f"""Analyze this email and decide initial routing:

{context}

Consider:
1. What does the email request?
2. What agents need to gather information before a response can be written?
3. Start with data gathering agents, save adaptive_writer for last

Return JSON:
{{
    "next_agent": "agent_name",
    "reasoning": "why you chose this agent to work first",
    "confidence": 0.0-1.0
}}"""

        try:
            response = await self._call_llm(user_prompt, system_prompt)
            decision = json.loads(response)

            # Validate next_agent is valid
            valid_agents = ["calendar_agent", "rag_agent", "crm_agent", "adaptive_writer", "FINISH"]
            if decision["next_agent"] not in valid_agents:
                logger.warning(f"Invalid agent {decision['next_agent']}, defaulting to adaptive_writer")
                decision["next_agent"] = "adaptive_writer"
                decision["reasoning"] = "Invalid routing corrected to adaptive_writer"

            # Prevent infinite loops - don't route to already completed agents
            if decision["next_agent"] in completed_agents and decision["next_agent"] != "adaptive_writer":
                logger.warning(f"🛑 LOOP PREVENTION: {decision['next_agent']} already completed, routing to adaptive_writer")
                decision["next_agent"] = "adaptive_writer"
                decision["reasoning"] = f"Loop prevention: {decision['next_agent']} already completed their work, routing to response writer"

            # Special case: if adaptive_writer is complete (has draft_response), route to FINISH
            if state.draft_response and state.current_agent == "adaptive_writer":
                logger.info("✅ Adaptive writer completed - draft response ready, routing to FINISH")
                decision["next_agent"] = "FINISH"
                decision["reasoning"] = "Adaptive writer completed with draft response - ready for human review"

            return decision

        except Exception as e:
            logger.error(f"Failed to parse routing decision: {e}")
            return {
                "next_agent": "adaptive_writer",
                "reasoning": f"Routing decision failed: {str(e)}",
                "confidence": 0.5
            }

    def _get_completed_agents(self, state: AgentState) -> List[str]:
        """
        Determine which agents have already completed their core work
        to prevent infinite routing loops.
        """
        completed = []

        # Check calendar agent completion
        if state.calendar_data and hasattr(state.calendar_data, 'action_taken'):
            action = str(state.calendar_data.action_taken).lower()
            if any(keyword in action for keyword in ["conflict", "alternative", "available", "suggested", "slots", "feel free to choose"]):
                completed.append("calendar_agent")
                logger.info("✅ Calendar agent marked as completed - provided conflict analysis/alternatives")

        # Check if calendar agent completed via messages
        if state.messages:
            for msg in state.messages[-5:]:  # Check recent messages
                if hasattr(msg, 'name') and getattr(msg, 'name') == 'calendar_agent':
                    content = str(getattr(msg, 'content', '')).lower()
                    if any(keyword in content for keyword in ["conflict", "alternative slots", "available", "suggested", "feel free to choose"]):
                        if "calendar_agent" not in completed:
                            completed.append("calendar_agent")
                            logger.info("✅ Calendar agent marked as completed via message analysis")

        # Check RAG agent completion
        if state.document_data:
            completed.append("rag_agent")
            logger.info("✅ RAG agent marked as completed - document data available")

        # Check CRM agent completion
        if state.contact_data:
            completed.append("crm_agent")
            logger.info("✅ CRM agent marked as completed - contact data available")

        return completed


# Lazy supervisor instance (created when needed to avoid initialization issues)
supervisor_agent = None


@traceable(name="supervisor_node", tags=["supervisor", "routing", "hub"])
async def supervisor_node(state: AgentState) -> Dict[str, Any]:
    """
    Main supervisor node for workflow integration.
    Uses hybrid supervisor to make intelligent routing decisions.
    Hub-and-spoke coordinator for all agent work.
    """
    global supervisor_agent
    if supervisor_agent is None:
        supervisor_agent = SupervisorAgent()

    logger.info("🧭 Supervisor node processing - hub-and-spoke coordination")
    result = await supervisor_agent.process(state)
    logger.info(f"📍 Supervisor routing decision: {result.get('current_agent', 'unknown')}")
    return result


def get_next_agent_from_state(state: AgentState) -> str:
    """
    Helper for workflow routing.
    Gets next agent from supervisor's routing decision.
    """
    logger.info("🔍 DEBUG: get_next_agent_from_state called")

    # Debug response_metadata structure
    response_metadata = state.response_metadata or {}
    logger.info(f"🔍 DEBUG: response_metadata keys: {list(response_metadata.keys())}")

    routing = response_metadata.get("routing", {})
    logger.info(f"🔍 DEBUG: routing keys: {list(routing.keys())}")
    logger.info(f"🔍 DEBUG: full routing object: {routing}")

    next_agent = routing.get("next", "END")
    logger.info(f"🔍 DEBUG: raw next_agent value: {next_agent}")

    # Check if supervisor actually made a routing decision
    if routing.get("supervisor_routed"):
        logger.info(f"✅ DEBUG: Supervisor routing confirmed with reasoning: {routing.get('reasoning', 'no reasoning')}")
    else:
        logger.warning("❌ DEBUG: No supervisor routing found - this might be the problem!")
        logger.warning(f"❌ DEBUG: Available metadata: {list(response_metadata.keys())}")

    final_result = next_agent if next_agent != "FINISH" else "END"
    logger.info(f"📍 Final routing result: {final_result}")

    return final_result
            - crm_agent: Manages contacts, customer data, relationship information, interaction history
            - adaptive_writer: ONLY runs AFTER other agents complete OR for simple direct responses with no special agents needs

            Routing principles:
            1. If dates/times are mentioned for scheduling → calendar_agent
            2. If specific information/documents are requested → rag_agent
            3. If contact/customer info is needed → crm_agent
            4. Multiple needs = multiple agents in sequence
            5. adaptive_writer ALWAYS runs last to compose final response

            Be comprehensive - identify ALL agents needed based on the extracted context."""

            prompt = f"""Based on the email_processor's analysis, determine routing:

EMAIL PARSING SUMMARY:
- Summary: {parsing.get('summary', 'N/A')}
- Main Request: {parsing.get('main_request', 'N/A')}
- Questions Asked: {json.dumps(parsing.get('questions_asked', []))}
- Key Points: {json.dumps(parsing.get('key_points', []))}
- Requires Response: {parsing.get('requires_response', True)}

EXTRACTED CONTEXT:
- Key Entities: {json.dumps(context.get('key_entities', [])[:10])}
- Dates Mentioned: {json.dumps(context.get('dates_mentioned', []))}
- Requested Actions: {json.dumps(context.get('requested_actions', []))}
- Requested Information: {json.dumps(context.get('requested_information', []))}
- Requested Data: {json.dumps(context.get('requested_data', []))}
- Requested Dates: {json.dumps(context.get('requested_dates', []))}
- References: {json.dumps(context.get('references', []))}
- Deadlines: {json.dumps(context.get('deadlines', []))}
- Urgency: {context.get('urgency_level', 'medium')}

ORIGINAL EMAIL:
Subject: {state.email.subject}
From: {state.email.sender}
Body preview: {state.email.body[:500]}...

Analyze ALL aspects and determine:
1. What specialized agents are needed (before adaptive_writer)?
2. What is the optimal execution order?
3. What specific task should each agent perform?
4. IMPORTANT:Be very specific about the task each agent should perform.
5. If it's a booking and a date, be very SPECIFIC and CLEARLY state the booking details.

Return JSON:
{{
    "detailed_analysis": {{
        "scheduling_needs": ["any calendar/time related needs"],
        "information_needs": ["any document/data retrieval needs"],
        "contact_needs": ["any CRM/contact related needs"],
        "detected_patterns": ["patterns suggesting specific agents"]
    }},
    "agent_assignments": {{
        "calendar_agent": {{"needed": true/false, "task": "specific task if needed"}},
        "rag_agent": {{"needed": true/false, "task": "specific task if needed"}},
        "crm_agent": {{"needed": true/false, "task": "specific task if needed"}}
    }},
    "execution_plan": ["ordered list of agents to execute"],
    "routing_rationale": "detailed explanation of routing logic",
    "confidence": 0.0-1.0
}}"""

            response = await self._call_llm(prompt, system_prompt)

            try:
                decision = json.loads(response)
                self.logger.info("Routing decision made", decision=decision)

                # Build execution order from agent assignments
                execution_order = []
                assignments = decision.get("agent_assignments", {})

                # Add agents in logical order
                for agent in ["calendar_agent", "rag_agent", "crm_agent"]:
                    if assignments.get(agent, {}).get("needed", False):
                        execution_order.append(agent)

                # Use provided plan if more comprehensive
                if decision.get("execution_plan"):
                    execution_order = [a for a in decision["execution_plan"]
                                     if a in ["calendar_agent", "rag_agent", "crm_agent"]]

                # Always add adaptive_writer last if other agents are needed
                if execution_order:
                    execution_order.append("adaptive_writer")
                else:
                    # No special agents needed, go straight to adaptive_writer
                    execution_order = ["adaptive_writer"]

                # Store comprehensive routing state
                state.response_metadata["routing"] = {
                    "analysis": decision.get("detailed_analysis", {}),
                    "assignments": assignments,
                    "execution_order": execution_order,
                    "completed_agents": [],
                    "failed_agents": [],
                    "agent_results": {},
                    "current_index": 0,
                    "started_at": datetime.now().isoformat(),
                    "rationale": decision.get("routing_rationale", ""),
                    "confidence": decision.get("confidence", 0.8),
                    "email_context": {
                        "summary": parsing.get("summary"),
                        "main_request": parsing.get("main_request"),
                        "questions": parsing.get("questions_asked", []),
                        "actions": context.get("requested_actions", [])
                    }
                }

                # Set first agent to execute
                if execution_order:
                    state.response_metadata["routing"]["next"] = execution_order[0]
                    state.response_metadata["routing"]["last_routed_to"] = execution_order[0]

                # Log routing decision
                agent_tasks = [
                    f"{agent}: {assignments.get(agent, {}).get('task', 'N/A')}"
                    for agent in execution_order[:-1]  # Exclude adaptive_writer from task list
                ]

                # Create routing message with modern pattern
                routing_message = self.create_ai_message(
                    f"Routing plan: {' → '.join(execution_order)}. "
                    f"Tasks: {'; '.join(agent_tasks) if agent_tasks else 'Direct response'}",
                    metadata=decision
                )

                return {
                    "messages": [routing_message],
                    "response_metadata": {"routing": state.response_metadata["routing"]}
                }

            except json.JSONDecodeError as e:
                self.logger.error(f"Failed to parse routing decision: {e}")
                return self._route_to_adaptive_writer(state, "Routing parse error")

        except Exception as e:
            self.logger.error(f"Routing analysis failed: {e}", exc_info=True)
            return self._route_to_adaptive_writer(state, f"Analysis error: {e}")

    def _is_returning_from_agent(self, state: AgentState) -> bool:
        """Check if returning from agent execution."""
        routing = state.response_metadata.get("routing", {})
        last_routed = routing.get("last_routed_to")
        completed = routing.get("completed_agents", [])

        # Check if we have evidence of agent execution
        has_agent_output = (
            (last_routed == "calendar_agent" and
             (state.calendar_data or "calendar" in str(state.messages[-1:]))),
            (last_routed == "rag_agent" and
             (state.document_data or "document" in str(state.messages[-1:]))),
            (last_routed == "crm_agent" and
             (state.contact_data or "contact" in str(state.messages[-1:])))
        )

        return (
            last_routed and
            last_routed not in completed and
            last_routed != "supervisor" and
            (any(has_agent_output) or state.status == "processing")
        )

    def _update_agent_progress(self, state: AgentState) -> Dict[str, Any]:
        """Update progress after agent completes."""
        routing = state.response_metadata["routing"]
        last_agent = routing.get("last_routed_to")

        if not last_agent:
            return {}

        self.logger.info(f"Agent {last_agent} completed execution")

        # Mark as completed
        if last_agent not in routing["completed_agents"]:
            routing["completed_agents"].append(last_agent)

            # Store agent-specific results
            assignments = routing.get("assignments", {})
            agent_task = assignments.get(last_agent, {}).get("task", "N/A")

            routing["agent_results"][last_agent] = {
                "completed": True,
                "task": agent_task,
                "timestamp": datetime.now().isoformat()
            }

            # Capture agent output data
            if last_agent == "calendar_agent" and state.calendar_data:
                routing["agent_results"][last_agent]["data"] = state.calendar_data.dict()
            elif last_agent == "rag_agent" and state.document_data:
                routing["agent_results"][last_agent]["data"] = state.document_data.dict()
            elif last_agent == "crm_agent" and state.contact_data:
                routing["agent_results"][last_agent]["data"] = state.contact_data.dict()

        # Advance to next agent
        execution_order = routing.get("execution_order", [])
        current_idx = routing.get("current_index", 0)

        if current_idx + 1 < len(execution_order):
            routing["current_index"] = current_idx + 1
            next_agent = execution_order[current_idx + 1]
            routing["next"] = next_agent
            routing["last_routed_to"] = next_agent

            self.logger.info(
                f"Progress: {len(routing['completed_agents'])}/{len(execution_order)-1} "
                f"specialized agents complete. Next: {next_agent}"
            )
        else:
            routing["next"] = "END"
            self.logger.info("All agents completed, ready for final response")
            return {
                "response_metadata": {"routing": routing},
                "status": "ready_for_response"
            }

        return {
            "response_metadata": {"routing": routing}
        }

    def _check_and_route_next(self, state: AgentState) -> Dict[str, Any]:
        """Determine next step in execution flow."""
        routing = state.response_metadata["routing"]
        next_agent = routing.get("next")

        if next_agent and next_agent != "END":
            self.logger.info(f"Continuing to: {next_agent}")
            return {}
        else:
            return {"status": "completed"}

    def _has_feedback(self, state: AgentState) -> bool:
        """Check for human feedback."""
        return bool(
            state.human_feedback or
            state.response_metadata.get("human_feedback") or
            state.response_metadata.get("decision") == "instruction"
        )

    def _handle_feedback_refinement(self, state: AgentState) -> Dict[str, Any]:
        """Route feedback to adaptive_writer."""
        self.logger.info("Processing human feedback")

        feedback_list = []
        if state.human_feedback:
            feedback_list.append(state.human_feedback)
        if "human_feedback" in state.response_metadata:
            historical = state.response_metadata["human_feedback"]
            feedback_list.extend(historical if isinstance(historical, list) else [historical])

        feedback_context = {
            "feedback_count": len(feedback_list),
            "all_feedback": feedback_list,
            "refinement_iteration": state.response_metadata.get("refinement_iteration", 0) + 1,
            "previous_draft": state.draft_response
        }

        routing = {
            "execution_order": ["adaptive_writer"],
            "next": "adaptive_writer",
            "last_routed_to": "adaptive_writer",
            "is_refinement": True,
            "completed_agents": []
        }

        return {
            "response_metadata": {
                "feedback_context": feedback_context,
                "routing": routing
            }
        }

    def _route_to_adaptive_writer(self, state: AgentState, reason: str) -> Dict[str, Any]:
        """Direct route to adaptive_writer."""
        routing = {
            "execution_order": ["adaptive_writer"],
            "next": "adaptive_writer",
            "last_routed_to": "adaptive_writer",
            "completed_agents": [],
            "rationale": reason
        }
        return {
            "response_metadata": {"routing": routing}
        }

    def get_next_agents(self, state: AgentState) -> List[str]:
        """Return next agent(s) to execute."""
        routing = state.response_metadata.get("routing", {})
        next_agent = routing.get("next")

        if next_agent and next_agent != "END":
            return [next_agent]
        return []
